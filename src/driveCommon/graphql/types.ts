// THIS FILE IS AUTOGENERATED BY GRAPHQL-CODEGEN. DO NOT EDIT!
import * as Apollo from '@apollo/client';
import { gql } from '@apollo/client';

export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
	ID: string;
	String: string;
	Boolean: boolean;
	Int: number;
	Float: number;
	/** A custom scalar representing a date in a timestamp format */
	DateTime: any;
};


/**  Definition of the File type which implements the Node interface */
export type File = Node & {
	__typename?: 'File';
	/**  Univoque identifier of the file */
	id: Scalars['ID'];
	/**  Creator of the file */
	creator: User;
	/**  Owner of the file */
	owner: User;
	/**  Last user who has edited the file */
	last_editor?: Maybe<User>;
	/**  File creation timestamp */
	created_at: Scalars['DateTime'];
	/**  File update timestamp */
	updated_at: Scalars['DateTime'];
	/**  File permissions of the user making the request */
	permissions: Permissions;
	/**  Name of the file */
	name: Scalars['String'];
	/**  Description of the file */
	description: Scalars['String'];
	/**  Type of the node */
	type: Scalars['String'];
	/**  Mime type of the file */
	mime_type: Scalars['String'];
	/**  Size of the file */
	size: Scalars['Int'];
	/**  Version of the file */
	version: Scalars['Int'];
	/**  Parent folder containing the file */
	parent: Node;
	/**  True if the owner has marked the folder as favourite, false otherwise */
	starred: Scalars['Boolean'];
	/**  True if the user has marked the folder for future deletion, false otherwise */
	marked_for_deletion: Scalars['Boolean'];
	/**  Specific share of the current file with the target user (if exists) */
	share?: Maybe<Share>;
	/**  List of shares of the current file (if they exist) */
	shares: Array<Maybe<Share>>;
	link?: Maybe<Link>;
};


/**  Definition of the File type which implements the Node interface */
export type FileShareArgs = {
	target_user_id: Scalars['ID'];
};


/**  Definition of the File type which implements the Node interface */
export type FileSharesArgs = {
	limit: Scalars['Int'];
	cursor?: Maybe<Scalars['String']>;
	sorts?: Maybe<Array<ShareSort>>;
};

/**  Definition of the Folder type which implements the Node interface */
export type Folder = Node & {
	__typename?: 'Folder';
	/**  Univoque identifier of the folder */
	id: Scalars['ID'];
	/**  Creator of the folder */
	creator: User;
	/**  Owner of the folder */
	owner: User;
	/**  Last user who has edited the folder */
	last_editor?: Maybe<User>;
	/**  Folder creation timestamp */
	created_at: Scalars['DateTime'];
	/**  Folder update timestamp */
	updated_at: Scalars['DateTime'];
	/**  Folder permissions of the user making the request */
	permissions: Permissions;
	/**  Name of the folder */
	name: Scalars['String'];
	/**  Description of the folder */
	description: Scalars['String'];
	/**  Type of the node */
	type: Scalars['String'];
	/**  Parent folder containing the folder. The parent can be null when the current folder is the root */
	parent?: Maybe<Node>;
	/**  True if the owner has marked the folder as favourite, false otherwise */
	starred: Scalars['Boolean'];
	/**  True if the user has marked the folder for future deletion, false otherwise */
	marked_for_deletion: Scalars['Boolean'];
	/**  List of all child nodes of a folder. */
	children: Array<Maybe<Node>>;
	/**  Specific share of the current folder with the target user (if exists) */
	share?: Maybe<Share>;
	/**  List of shares of the current folder (if they exist) */
	shares: Array<Maybe<Share>>;
	link?: Maybe<Link>;
};


/**  Definition of the Folder type which implements the Node interface */
export type FolderChildrenArgs = {
	limit: Scalars['Int'];
	cursor?: Maybe<Scalars['String']>;
	sorts?: Maybe<Array<NodeSort>>;
};


/**  Definition of the Folder type which implements the Node interface */
export type FolderShareArgs = {
	target_user_id: Scalars['ID'];
};


/**  Definition of the Folder type which implements the Node interface */
export type FolderSharesArgs = {
	limit: Scalars['Int'];
	cursor?: Maybe<Scalars['String']>;
	sorts?: Maybe<Array<ShareSort>>;
};

/**  Definition of the Link type. It represents a public or private link of a specific node. */
export type Link = {
	__typename?: 'Link';
	/**  Full url to access the related node. Every node has one and only one url. */
	url: Scalars['String'];
	/**  Node related to this link. */
	node: Node;
	/**  Link creation timestamp */
	created_at: Scalars['DateTime'];
	/**
	 * Represents the visibility of the link. If it is public then everybody can access the related node,
	 * otherwise the node can be accessed only by the users to whom it was shared.
	 */
	public: Scalars['Boolean'];
	/**  Link expiration timestamp */
	expires_at?: Maybe<Scalars['DateTime']>;
	/**  Link password. If enabled, only the user that know the password can access the node. */
	password?: Maybe<Scalars['String']>;
};

export type Mutation = {
	__typename?: 'Mutation';
	/**  <strong>Creates a new folder</strong> */
	createFolder: Node;
	/**  <strong>Update an existing node</strong> */
	updateNode: Node;
	/**  Allows to star a list of nodes. */
	starNodes?: Maybe<Array<Scalars['ID']>>;
	/**  Allows to mark for deletion a list of nodes. */
	markNodesForDeletion?: Maybe<Array<Scalars['ID']>>;
	/**  Allows to move a list of nodes into a folder destination. This operation requires write permissions on the destination folder otherwise it fails. */
	moveNodes?: Maybe<Array<Node>>;
	/**  Allows to delete a list of nodes. For each node you can optionally specify a version for a file. */
	deleteNodes?: Maybe<Array<Scalars['ID']>>;
	/**
	 * Allows to share an existing node to a user specifing the user permissions on that node,
	 * and, optionally, an expiration timestamp.
	 */
	createShare: Share;
	/**  Allows to update the SharePermissions and the expiration timestamp of an existing share. */
	updateShare?: Maybe<Share>;
	/**
	 * Allows to delete the share of a node to a target user. It returns false if the share does not exist or the operation
	 * fails, otherwise it returns true.
	 */
	deleteShare: Scalars['Boolean'];
	/**
	 * Allows to create a public/private link for an existing node.
	 * Optionally, an expiration timestamp and/or a password can be set.
	 */
	createLink: Link;
	/**  Allows to update the visibility, the expiration timestamp and/or the password of an existing link. */
	updateLink?: Maybe<Link>;
	/**
	 * Allows to delete a link of a node. It returns false if the link does not exist or the operation fails,
	 * otherwise it returns true.
	 */
	deleteLink: Scalars['Boolean'];
};


export type MutationCreateFolderArgs = {
	parent_id: Scalars['String'];
	name: Scalars['String'];
};


export type MutationUpdateNodeArgs = {
	id: Scalars['String'];
	name?: Maybe<Scalars['String']>;
	description?: Maybe<Scalars['String']>;
	starred?: Maybe<Scalars['Boolean']>;
	marked_for_deletion?: Maybe<Scalars['Boolean']>;
};


export type MutationStarNodesArgs = {
	nodes_ids?: Maybe<Array<Scalars['ID']>>;
	star: Scalars['Boolean'];
};


export type MutationMarkNodesForDeletionArgs = {
	nodes_ids?: Maybe<Array<Scalars['ID']>>;
	mark_for_deletion: Scalars['Boolean'];
};


export type MutationMoveNodesArgs = {
	nodes_ids?: Maybe<Array<Scalars['ID']>>;
	destination_id: Scalars['ID'];
};


export type MutationDeleteNodesArgs = {
	nodes?: Maybe<Array<NodeInput>>;
};


export type MutationCreateShareArgs = {
	node_id: Scalars['ID'];
	target_user_id: Scalars['ID'];
	permissions: SharePermissions;
	expires_at?: Maybe<Scalars['DateTime']>;
};


export type MutationUpdateShareArgs = {
	node_id: Scalars['ID'];
	target_user_id: Scalars['ID'];
	permissions?: Maybe<SharePermissions>;
	expires_at?: Maybe<Scalars['DateTime']>;
};


export type MutationDeleteShareArgs = {
	node_id: Scalars['ID'];
	target_user_id: Scalars['ID'];
};


export type MutationCreateLinkArgs = {
	node_id: Scalars['ID'];
	public: Scalars['Boolean'];
	expires_at?: Maybe<Scalars['DateTime']>;
	password?: Maybe<Scalars['String']>;
};


export type MutationUpdateLinkArgs = {
	node_id: Scalars['ID'];
	public?: Maybe<Scalars['Boolean']>;
	expires_at?: Maybe<Scalars['DateTime']>;
	password?: Maybe<Scalars['String']>;
};


export type MutationDeleteLinkArgs = {
	node_id: Scalars['ID'];
};

/**  Definition of the Node interface */
export type Node = {
	/**  Univoque identifier of the node */
	id: Scalars['ID'];
	/**  Creator of the node (it will be a User type when it will be implemented) */
	creator: User;
	/**  Owner of the node (it will be a User type when it will be implemented) */
	owner: User;
	/**  Last user who has edited the node (it will be a User type when it will be implemented) */
	last_editor?: Maybe<User>;
	/**  Node creation timestamp */
	created_at: Scalars['DateTime'];
	/**  Node update timestamp */
	updated_at: Scalars['DateTime'];
	/**  Node permissions of the user making the request */
	permissions: Permissions;
	/**  Name of the file/folder */
	name: Scalars['String'];
	/**  Description of the file/folder */
	description: Scalars['String'];
	/**  Type of the node */
	type: Scalars['String'];
	/**  True if the owner has marked the node as favourite, false otherwise */
	starred: Scalars['Boolean'];
	/**  True if the user has marked the node for future deletion, false otherwise */
	marked_for_deletion: Scalars['Boolean'];
	/**  Parent folder containing the node. The parent can be null when the current node is the root folder */
	parent?: Maybe<Node>;
	/**  Specific share of the current node with the target user (if exists) */
	share?: Maybe<Share>;
	/**  List of shares of the current node (if they exist) */
	shares: Array<Maybe<Share>>;
	link?: Maybe<Link>;
};


/**  Definition of the Node interface */
export type NodeShareArgs = {
	target_user_id: Scalars['ID'];
};


/**  Definition of the Node interface */
export type NodeSharesArgs = {
	limit: Scalars['Int'];
	cursor?: Maybe<Scalars['String']>;
	sorts?: Maybe<Array<ShareSort>>;
};

export type NodeInput = {
	node_id: Scalars['ID'];
	version?: Maybe<Scalars['Int']>;
};

/**  Definition of the NodeSort enumerator. This is useful for sorting the result of a list of nodes. */
export enum NodeSort {
	LastEditorAsc = 'LAST_EDITOR_ASC',
	LastEditorDesc = 'LAST_EDITOR_DESC',
	MarkForDeletionAsc = 'MARK_FOR_DELETION_ASC',
	MarkForDeletionDesc = 'MARK_FOR_DELETION_DESC',
	NameAsc = 'NAME_ASC',
	NameDesc = 'NAME_DESC',
	OwnerAsc = 'OWNER_ASC',
	OwnerDesc = 'OWNER_DESC',
	TypeAsc = 'TYPE_ASC',
	TypeDesc = 'TYPE_DESC',
	UpdatedAtAsc = 'UPDATED_AT_ASC',
	UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type NodeSubscription = {
	__typename?: 'NodeSubscription';
	/**  Univoque identifier of the node */
	id: Scalars['ID'];
	/**  Node creation timestamp */
	created_at: Scalars['DateTime'];
	/**  Node update timestamp */
	updated_at: Scalars['DateTime'];
	/**  Name of the file/folder */
	name: Scalars['String'];
	/**  Description of the file/folder */
	description: Scalars['String'];
	/**  Type of the node */
	type: Scalars['String'];
	/**  True if the owner has marked the node as favourite, false otherwise */
	starred: Scalars['Boolean'];
	/**  True if the user has marked the node for future deletion, false otherwise */
	marked_for_deletion: Scalars['Boolean'];
};

/**  Definition of Permissions type. It represents all the permissions that the requester user has on a specific node. */
export type Permissions = {
	__typename?: 'Permissions';
	can_rename: Scalars['Boolean'];
	can_move: Scalars['Boolean'];
	can_copy: Scalars['Boolean'];
	can_upload: Scalars['Boolean'];
	can_delete: Scalars['Boolean'];
	can_mark_for_deletion: Scalars['Boolean'];
	can_change_description: Scalars['Boolean'];
	can_change_star: Scalars['Boolean'];
	can_add_version: Scalars['Boolean'];
	can_read_link: Scalars['Boolean'];
	can_change_link: Scalars['Boolean'];
	can_share: Scalars['Boolean'];
	can_read_share: Scalars['Boolean'];
	can_change_share: Scalars['Boolean'];
};

export type Query = {
	__typename?: 'Query';
	/**  <strong>Returns the attributes of the node specified by ID</strong> */
	getNode?: Maybe<Node>;
	getFileVersions: Array<Maybe<File>>;
	getUserById?: Maybe<User>;
	getUserByEmail?: Maybe<User>;
	/**  Returns the attributes of the specified share */
	getShare?: Maybe<Share>;
	/**  Returns the attributes of a link of the specified node */
	getLink?: Maybe<Link>;
};


export type QueryGetNodeArgs = {
	id: Scalars['ID'];
	version?: Maybe<Scalars['Int']>;
};


export type QueryGetFileVersionsArgs = {
	id: Scalars['ID'];
};


export type QueryGetUserByIdArgs = {
	id: Scalars['ID'];
};


export type QueryGetUserByEmailArgs = {
	email: Scalars['String'];
};


export type QueryGetShareArgs = {
	node_id: Scalars['ID'];
	target_user_id: Scalars['ID'];
};


export type QueryGetLinkArgs = {
	node_id: Scalars['ID'];
};

/**  Definition of the Share type. It represents a share between a node and a user. */
export type Share = {
	__typename?: 'Share';
	/**  Share creation timestamp */
	created_at: Scalars['DateTime'];
	/**  Node shared */
	node: Node;
	/**  User to whom a node has been shared */
	target_user: User;
	/**  User permission for the node */
	permissions: Permissions;
	/**  Share expiration timestamp */
	expires_at?: Maybe<Scalars['DateTime']>;
};

/**  The SharePermissions enumerator represents the permissions of a node shared with a user */
export enum SharePermissions {
	ReadOnly = 'READ_ONLY',
	ReadAndWrite = 'READ_AND_WRITE',
	ReadAndShare = 'READ_AND_SHARE',
	ReadWriteAndShare = 'READ_WRITE_AND_SHARE'
}

/**  Definition of the ShareSort enumerator. This is useful for sorting the result of a list of shares. */
export enum ShareSort {
	CreationAsc = 'CREATION_ASC',
	CreationDesc = 'CREATION_DESC',
	/**  The order is based on the target user identifier and not on his email or display name. */
	TargetUserAsc = 'TARGET_USER_ASC',
	/**  The order is based on the target user identifier and not on his email or display name. */
	TargetUserDesc = 'TARGET_USER_DESC',
	/**  The order is ascending: this means that first are shown the shares with fewer permissions. */
	SharePermissionsAsc = 'SHARE_PERMISSIONS_ASC',
	/**  The order is discending: this means that first are shown the shares with more permissions. */
	SharePermissionsDesc = 'SHARE_PERMISSIONS_DESC',
	ExpirationAsc = 'EXPIRATION_ASC',
	ExpirationDesc = 'EXPIRATION_DESC'
}

export type Subscription = {
	__typename?: 'Subscription';
	nodeSubscription: NodeSubscription;
};


export type SubscriptionNodeSubscriptionArgs = {
	ids: Array<Maybe<Scalars['String']>>;
};

/**  Definition of the User type */
export type User = {
	__typename?: 'User';
	/**  Univoque identifier of the folder */
	id: Scalars['ID'];
	/**  Email of the user */
	email: Scalars['String'];
	/**  Full name of the user */
	full_name: Scalars['String'];
};

type BaseNode_File_Fragment = (
	{ __typename?: 'File' }
	& Pick<File, 'size' | 'mime_type' | 'id' | 'name' | 'type' | 'starred'>
	& Permissions_File_Fragment
	);

type BaseNode_Folder_Fragment = (
	{ __typename?: 'Folder' }
	& Pick<Folder, 'id' | 'name' | 'type' | 'starred'>
	& Permissions_Folder_Fragment
	);

export type BaseNodeFragment = BaseNode_File_Fragment | BaseNode_Folder_Fragment;

type BaseParent_File_Fragment = (
	{ __typename?: 'File' }
	& Pick<File, 'id' | 'name'>
	);

type BaseParent_Folder_Fragment = (
	{ __typename?: 'Folder' }
	& Pick<Folder, 'id' | 'name'>
	);

export type BaseParentFragment = BaseParent_File_Fragment | BaseParent_Folder_Fragment;

type Parents_File_Fragment = (
	{ __typename?: 'File' }
	& {
	parent: (
		{ __typename?: 'File' }
		& {
		parent: (
			{ __typename?: 'File' }
			& {
			parent: (
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)
		}
			& BaseParent_File_Fragment
			) | (
			{ __typename?: 'Folder' }
			& {
			parent?: Maybe<(
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)>
		}
			& BaseParent_Folder_Fragment
			)
	}
		& BaseParent_File_Fragment
		) | (
		{ __typename?: 'Folder' }
		& {
		parent?: Maybe<(
			{ __typename?: 'File' }
			& {
			parent: (
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)
		}
			& BaseParent_File_Fragment
			) | (
			{ __typename?: 'Folder' }
			& {
			parent?: Maybe<(
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)>
		}
			& BaseParent_Folder_Fragment
			)>
	}
		& BaseParent_Folder_Fragment
		)
}
	& BaseParent_File_Fragment
	);

type Parents_Folder_Fragment = (
	{ __typename?: 'Folder' }
	& {
	parent?: Maybe<(
		{ __typename?: 'File' }
		& {
		parent: (
			{ __typename?: 'File' }
			& {
			parent: (
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)
		}
			& BaseParent_File_Fragment
			) | (
			{ __typename?: 'Folder' }
			& {
			parent?: Maybe<(
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)>
		}
			& BaseParent_Folder_Fragment
			)
	}
		& BaseParent_File_Fragment
		) | (
		{ __typename?: 'Folder' }
		& {
		parent?: Maybe<(
			{ __typename?: 'File' }
			& {
			parent: (
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)
		}
			& BaseParent_File_Fragment
			) | (
			{ __typename?: 'Folder' }
			& {
			parent?: Maybe<(
				{ __typename?: 'File' }
				& BaseParent_File_Fragment
				) | (
				{ __typename?: 'Folder' }
				& BaseParent_Folder_Fragment
				)>
		}
			& BaseParent_Folder_Fragment
			)>
	}
		& BaseParent_Folder_Fragment
		)>
}
	& BaseParent_Folder_Fragment
	);

export type ParentsFragment = Parents_File_Fragment | Parents_Folder_Fragment;

type Permissions_File_Fragment = (
	{ __typename?: 'File' }
	& {
	permissions: (
		{ __typename?: 'Permissions' }
		& Pick<Permissions, 'can_rename' | 'can_move' | 'can_copy' | 'can_upload' | 'can_delete' | 'can_mark_for_deletion' | 'can_change_description' | 'can_change_star' | 'can_add_version' | 'can_read_link' | 'can_change_link' | 'can_share' | 'can_read_share' | 'can_change_share'>
		)
}
	);

type Permissions_Folder_Fragment = (
	{ __typename?: 'Folder' }
	& {
	permissions: (
		{ __typename?: 'Permissions' }
		& Pick<Permissions, 'can_rename' | 'can_move' | 'can_copy' | 'can_upload' | 'can_delete' | 'can_mark_for_deletion' | 'can_change_description' | 'can_change_star' | 'can_add_version' | 'can_read_link' | 'can_change_link' | 'can_share' | 'can_read_share' | 'can_change_share'>
		)
}
	);

export type PermissionsFragment = Permissions_File_Fragment | Permissions_Folder_Fragment;

export type FlagNodesMutationVariables = Exact<{
	nodes_ids?: Maybe<Array<Scalars['ID']> | Scalars['ID']>;
	flag: Scalars['Boolean'];
}>;


export type FlagNodesMutation = (
	{ __typename?: 'Mutation' }
	& Pick<Mutation, 'starNodes'>
	);

export type GetChildrenQueryVariables = Exact<{
	parentNode: Scalars['ID'];
	childrenLimit: Scalars['Int'];
	sorts?: Maybe<Array<NodeSort> | NodeSort>;
}>;


export type GetChildrenQuery = (
	{ __typename?: 'Query' }
	& {
	getNode?: Maybe<(
		{ __typename?: 'File' }
		& Pick<File, 'id' | 'name'>
		) | (
		{ __typename?: 'Folder' }
		& Pick<Folder, 'id' | 'name'>
		& {
		children: Array<Maybe<(
			{ __typename?: 'File' }
			& Pick<File, 'updated_at'>
			& {
			owner: (
				{ __typename?: 'User' }
				& Pick<User, 'id' | 'full_name'>
				), last_editor?: Maybe<(
				{ __typename?: 'User' }
				& Pick<User, 'id' | 'full_name'>
				)>, link?: Maybe<(
				{ __typename?: 'Link' }
				& Pick<Link, 'expires_at'>
				)>
		}
			& BaseNode_File_Fragment
			) | (
			{ __typename?: 'Folder' }
			& Pick<Folder, 'updated_at'>
			& {
			owner: (
				{ __typename?: 'User' }
				& Pick<User, 'id' | 'full_name'>
				), last_editor?: Maybe<(
				{ __typename?: 'User' }
				& Pick<User, 'id' | 'full_name'>
				)>, link?: Maybe<(
				{ __typename?: 'Link' }
				& Pick<Link, 'expires_at'>
				)>
		}
			& BaseNode_Folder_Fragment
			)>>
	}
		)>
}
	);

export type GetParentsQueryVariables = Exact<{
	id: Scalars['ID'];
}>;


export type GetParentsQuery = (
	{ __typename?: 'Query' }
	& {
	getNode?: Maybe<(
		{ __typename?: 'File' }
		& Parents_File_Fragment
		) | (
		{ __typename?: 'Folder' }
		& Parents_Folder_Fragment
		)>
}
	);

export type GetPermissionsQueryVariables = Exact<{
	id: Scalars['ID'];
}>;


export type GetPermissionsQuery = (
	{ __typename?: 'Query' }
	& {
	getNode?: Maybe<(
		{ __typename?: 'File' }
		& Permissions_File_Fragment
		) | (
		{ __typename?: 'Folder' }
		& Permissions_Folder_Fragment
		)>
}
	);

export const PermissionsFragmentDoc = gql`
    fragment Permissions on Node {
        permissions {
            can_rename
            can_move
            can_copy
            can_upload
            can_delete
            can_mark_for_deletion
            can_change_description
            can_change_star
            can_add_version
            can_read_link
            can_change_link
            can_share
            can_read_share
            can_change_share
        }
    }
`;
export const BaseNodeFragmentDoc = gql`
    fragment BaseNode on Node {
        id
        name
        type
        ...Permissions
        ... on File {
            size
            mime_type
        }
        starred
    }
${PermissionsFragmentDoc}`;
export const BaseParentFragmentDoc = gql`
    fragment BaseParent on Node {
        id
        name
    }
`;
export const ParentsFragmentDoc = gql`
    fragment Parents on Node {
        ...BaseParent
        parent {
            ...BaseParent
            parent {
                ...BaseParent
                parent {
                    ...BaseParent
                }
            }
        }
    }
${BaseParentFragmentDoc}`;
export const FlagNodesDocument = gql`
    mutation flagNodes($nodes_ids: [ID!], $flag: Boolean!) {
        starNodes(nodes_ids: $nodes_ids, star: $flag)
    }
`;
export type FlagNodesMutationFn = Apollo.MutationFunction<FlagNodesMutation, FlagNodesMutationVariables>;

/**
 * __useFlagNodesMutation__
 *
 * To run a mutation, you first call `useFlagNodesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFlagNodesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [flagNodesMutation, { data, loading, error }] = useFlagNodesMutation({
 *   variables: {
 *      nodes_ids: // value for 'nodes_ids'
 *      flag: // value for 'flag'
 *   },
 * });
 */
export function useFlagNodesMutation(baseOptions?: Apollo.MutationHookOptions<FlagNodesMutation, FlagNodesMutationVariables>) {
	return Apollo.useMutation<FlagNodesMutation, FlagNodesMutationVariables>(FlagNodesDocument, baseOptions);
}

export type FlagNodesMutationHookResult = ReturnType<typeof useFlagNodesMutation>;
export type FlagNodesMutationResult = Apollo.MutationResult<FlagNodesMutation>;
export type FlagNodesMutationOptions = Apollo.BaseMutationOptions<FlagNodesMutation, FlagNodesMutationVariables>;
export const GetChildrenDocument = gql`
    query getChildren($parentNode: ID!, $childrenLimit: Int!, $sorts: [NodeSort!]) {
        getNode(id: $parentNode) {
            id
            name
            ... on Folder {
                children(limit: $childrenLimit, sorts: $sorts) {
                    ...BaseNode
                    owner {
                        id
                        full_name
                    }
                    last_editor {
                        id
                        full_name
                    }
                    updated_at
                    link {
                        expires_at
                    }
                }
            }
        }
    }
${BaseNodeFragmentDoc}`;

/**
 * __useGetChildrenQuery__
 *
 * To run a query within a React component, call `useGetChildrenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChildrenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChildrenQuery({
 *   variables: {
 *      parentNode: // value for 'parentNode'
 *      childrenLimit: // value for 'childrenLimit'
 *      sorts: // value for 'sorts'
 *   },
 * });
 */
export function useGetChildrenQuery(baseOptions: Apollo.QueryHookOptions<GetChildrenQuery, GetChildrenQueryVariables>) {
	return Apollo.useQuery<GetChildrenQuery, GetChildrenQueryVariables>(GetChildrenDocument, baseOptions);
}

export function useGetChildrenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChildrenQuery, GetChildrenQueryVariables>) {
	return Apollo.useLazyQuery<GetChildrenQuery, GetChildrenQueryVariables>(GetChildrenDocument, baseOptions);
}

export type GetChildrenQueryHookResult = ReturnType<typeof useGetChildrenQuery>;
export type GetChildrenLazyQueryHookResult = ReturnType<typeof useGetChildrenLazyQuery>;
export type GetChildrenQueryResult = Apollo.QueryResult<GetChildrenQuery, GetChildrenQueryVariables>;
export const GetParentsDocument = gql`
    query getParents($id: ID!) {
        getNode(id: $id) {
            ...Parents
        }
    }
${ParentsFragmentDoc}`;

/**
 * __useGetParentsQuery__
 *
 * To run a query within a React component, call `useGetParentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetParentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetParentsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetParentsQuery(baseOptions: Apollo.QueryHookOptions<GetParentsQuery, GetParentsQueryVariables>) {
	return Apollo.useQuery<GetParentsQuery, GetParentsQueryVariables>(GetParentsDocument, baseOptions);
}

export function useGetParentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetParentsQuery, GetParentsQueryVariables>) {
	return Apollo.useLazyQuery<GetParentsQuery, GetParentsQueryVariables>(GetParentsDocument, baseOptions);
}

export type GetParentsQueryHookResult = ReturnType<typeof useGetParentsQuery>;
export type GetParentsLazyQueryHookResult = ReturnType<typeof useGetParentsLazyQuery>;
export type GetParentsQueryResult = Apollo.QueryResult<GetParentsQuery, GetParentsQueryVariables>;
export const GetPermissionsDocument = gql`
    query getPermissions($id: ID!) {
        getNode(id: $id) {
            ...Permissions
        }
    }
${PermissionsFragmentDoc}`;

/**
 * __useGetPermissionsQuery__
 *
 * To run a query within a React component, call `useGetPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPermissionsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPermissionsQuery(baseOptions: Apollo.QueryHookOptions<GetPermissionsQuery, GetPermissionsQueryVariables>) {
	return Apollo.useQuery<GetPermissionsQuery, GetPermissionsQueryVariables>(GetPermissionsDocument, baseOptions);
}

export function useGetPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPermissionsQuery, GetPermissionsQueryVariables>) {
	return Apollo.useLazyQuery<GetPermissionsQuery, GetPermissionsQueryVariables>(GetPermissionsDocument, baseOptions);
}

export type GetPermissionsQueryHookResult = ReturnType<typeof useGetPermissionsQuery>;
export type GetPermissionsLazyQueryHookResult = ReturnType<typeof useGetPermissionsLazyQuery>;
export type GetPermissionsQueryResult = Apollo.QueryResult<GetPermissionsQuery, GetPermissionsQueryVariables>;
